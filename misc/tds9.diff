? DBD-ODBC-1.13.tar.gz
? dump.txt
? errors.txt
? freetds-0.65.dev.20071015
? freetds-0.65.dev.20071015.tar.gz
? freetds-0.65.dev.20071015.win32.tar.gz
? mao.diff
? php5.2-latest.tar.bz2
? vedi.diff
? win32_errors.txt
? src/code
? src/code.cpp
? src/out.txt
? src/apps/bsqldb.gcno
? src/apps/bsqlodbc.gcno
? src/apps/datacopy.gcno
? src/apps/defncopy.gcno
? src/apps/freebcp.gcno
? src/apps/tsql.gcno
? src/apps/fisql/edit.gcno
? src/apps/fisql/fisql.gcno
? src/apps/fisql/handlers.gcno
? src/apps/fisql/interrupt.gcno
? src/apps/fisql/terminal.gcno
? src/ctlib/blk.gcno
? src/ctlib/cs.gcno
? src/ctlib/ct.gcno
? src/ctlib/ctutil.gcno
? src/ctlib/unittests/array_bind.gcno
? src/ctlib/unittests/blk_in.gcno
? src/ctlib/unittests/blk_in2.gcno
? src/ctlib/unittests/blk_out.gcno
? src/ctlib/unittests/cancel.gcno
? src/ctlib/unittests/common.gcno
? src/ctlib/unittests/connect_fail.gcno
? src/ctlib/unittests/cs_config.gcno
? src/ctlib/unittests/cs_diag.gcno
? src/ctlib/unittests/ct_cursor.gcno
? src/ctlib/unittests/ct_cursors.gcno
? src/ctlib/unittests/ct_diagall.gcno
? src/ctlib/unittests/ct_diagclient.gcno
? src/ctlib/unittests/ct_diagserver.gcno
? src/ctlib/unittests/ct_dynamic.gcno
? src/ctlib/unittests/ct_options.gcno
? src/ctlib/unittests/get_send_data.gcno
? src/ctlib/unittests/lang_ct_param.gcno
? src/ctlib/unittests/mao.html
? src/ctlib/unittests/rpc_ct_param.gcno
? src/ctlib/unittests/rpc_ct_setparam.gcno
? src/ctlib/unittests/t0001.gcno
? src/ctlib/unittests/t0002.gcno
? src/ctlib/unittests/t0003.gcno
? src/ctlib/unittests/t0004.gcno
? src/ctlib/unittests/t0005.gcno
? src/ctlib/unittests/t0006.gcno
? src/ctlib/unittests/t0007.gcno
? src/ctlib/unittests/t0008.gcno
? src/ctlib/unittests/t0009.gcno
? src/dblib/bcp.gcno
? src/dblib/dblib.gcno
? src/dblib/dbutil.gcno
? src/dblib/rpc.gcno
? src/dblib/xact.gcno
? src/dblib/unittests/bcp.gcno
? src/dblib/unittests/common.gcno
? src/dblib/unittests/dbmorecmds.gcno
? src/dblib/unittests/done_handling.gcno
? src/dblib/unittests/hang.gcno
? src/dblib/unittests/rpc.gcno
? src/dblib/unittests/t0001.gcno
? src/dblib/unittests/t0002.gcno
? src/dblib/unittests/t0003.gcno
? src/dblib/unittests/t0004.gcno
? src/dblib/unittests/t0005.gcno
? src/dblib/unittests/t0006.gcno
? src/dblib/unittests/t0007.gcno
? src/dblib/unittests/t0008.gcno
? src/dblib/unittests/t0009.gcno
? src/dblib/unittests/t0011.gcno
? src/dblib/unittests/t0012.gcno
? src/dblib/unittests/t0013.gcno
? src/dblib/unittests/t0014.gcno
? src/dblib/unittests/t0015.gcno
? src/dblib/unittests/t0016.gcno
? src/dblib/unittests/t0017.gcno
? src/dblib/unittests/t0018.gcno
? src/dblib/unittests/t0019.gcno
? src/dblib/unittests/t0020.gcno
? src/dblib/unittests/t0021.gcno
? src/dblib/unittests/t0022.gcno
? src/dblib/unittests/t0023.gcno
? src/dblib/unittests/text_buffer.gcno
? src/dblib/unittests/thread.gcno
? src/dblib/unittests/timeout.gcno
? src/odbc/connectparams.gcno
? src/odbc/convert_tds2sql.gcno
? src/odbc/descriptor.gcno
? src/odbc/error.gcno
? src/odbc/native.gcno
? src/odbc/odbc.gcno
? src/odbc/odbc_checks.gcno
? src/odbc/odbc_util.gcno
? src/odbc/prepare_query.gcno
? src/odbc/sql2tds.gcno
? src/odbc/unittests/array.gcno
? src/odbc/unittests/array_out.gcno
? src/odbc/unittests/binary_test.gcno
? src/odbc/unittests/common.gcno
? src/odbc/unittests/compute.gcno
? src/odbc/unittests/connect.gcno
? src/odbc/unittests/connect2.gcno
? src/odbc/unittests/const_params.gcno
? src/odbc/unittests/convert_error.gcno
? src/odbc/unittests/copydesc.gcno
? src/odbc/unittests/cursor1.gcno
? src/odbc/unittests/cursor2.gcno
? src/odbc/unittests/data.gcno
? src/odbc/unittests/date.gcno
? src/odbc/unittests/describecol.gcno
? src/odbc/unittests/earlybind.gcno
? src/odbc/unittests/error.gcno
? src/odbc/unittests/freeclose.gcno
? src/odbc/unittests/funccall.gcno
? src/odbc/unittests/genparams.gcno
? src/odbc/unittests/getdata.gcno
? src/odbc/unittests/insert_speed.gcno
? src/odbc/unittests/lang_error.gcno
? src/odbc/unittests/moreandcount.gcno
? src/odbc/unittests/norowset.gcno
? src/odbc/unittests/paramcore.gcno
? src/odbc/unittests/params.gcno
? src/odbc/unittests/prepare_results.gcno
? src/odbc/unittests/prepclose.gcno
? src/odbc/unittests/preperror.gcno
? src/odbc/unittests/print.gcno
? src/odbc/unittests/putdata.gcno
? src/odbc/unittests/raiserror.gcno
? src/odbc/unittests/rebindpar.gcno
? src/odbc/unittests/rpc.gcno
? src/odbc/unittests/scroll.gcno
? src/odbc/unittests/t0001.gcno
? src/odbc/unittests/t0002.gcno
? src/odbc/unittests/t0003.gcno
? src/odbc/unittests/t0004.gcno
? src/odbc/unittests/tables.gcno
? src/odbc/unittests/testodbc.gcno
? src/odbc/unittests/timeout.gcno
? src/odbc/unittests/timeout2.gcno
? src/odbc/unittests/timeout3.gcno
? src/odbc/unittests/timeout4.gcno
? src/odbc/unittests/transaction.gcno
? src/odbc/unittests/type.gcno
? src/odbc/unittests/typeinfo.gcno
? src/odbc/unittests/warning.gcno
? src/pool/config.gcno
? src/pool/main.gcno
? src/pool/member.gcno
? src/pool/user.gcno
? src/pool/util.gcno
? src/replacements/readpassphrase.gcno
? src/replacements/strlcat.gcno
? src/replacements/strlcpy.gcno
? src/server/login.gcno
? src/server/query.gcno
? src/server/server.gcno
? src/server/unittest.gcno
? src/tds/challenge.gcno
? src/tds/config.gcno
? src/tds/convert.gcno
? src/tds/data.gcno
? src/tds/des.gcno
? src/tds/getmac.gcno
? src/tds/iconv.gcno
? src/tds/locale.gcno
? src/tds/log.gcno
? src/tds/login.gcno
? src/tds/md4.gcno
? src/tds/md5.gcno
? src/tds/mem.gcno
? src/tds/net.gcno
? src/tds/numeric.gcno
? src/tds/query.gcno
? src/tds/read.gcno
? src/tds/tds_checks.gcno
? src/tds/tdsstring.gcno
? src/tds/threadsafe.gcno
? src/tds/token.gcno
? src/tds/util.gcno
? src/tds/vstrbuild.gcno
? src/tds/write.gcno
? src/tds/unittests/common.gcno
? src/tds/unittests/convert.gcno
? src/tds/unittests/dataread.gcno
? src/tds/unittests/dynamic1.gcno
? src/tds/unittests/iconv_fread.gcno
? src/tds/unittests/numeric.gcno
? src/tds/unittests/t0001.gcno
? src/tds/unittests/t0002.gcno
? src/tds/unittests/t0003.gcno
? src/tds/unittests/t0004.gcno
? src/tds/unittests/t0005.gcno
? src/tds/unittests/t0006.gcno
? src/tds/unittests/t0007.gcno
? src/tds/unittests/t0008.gcno
? src/tds/unittests/utf8_1.gcno
? src/tds/unittests/utf8_2.gcno
? src/tds/unittests/utf8_3.gcno
Index: include/tds.h
===================================================================
RCS file: /cvsroot/freetds/freetds/include/tds.h,v
retrieving revision 1.274
diff -u -1 -0 -r1.274 tds.h
--- include/tds.h	24 Aug 2007 09:51:37 -0000	1.274
+++ include/tds.h	18 Oct 2007 08:22:15 -0000
@@ -382,20 +382,23 @@
 #define GOTO_1ST_ROW    3
 #define LOGIN           4
 
 /* environment type field */
 #define TDS_ENV_DATABASE  	1
 #define TDS_ENV_LANG      	2
 #define TDS_ENV_CHARSET   	3
 #define TDS_ENV_PACKSIZE  	4
 #define TDS_ENV_LCID        	5
 #define TDS_ENV_SQLCOLLATION	7
+#define TDS_ENV_BEGINTRANS	8
+#define TDS_ENV_COMMITTRANS	9
+#define TDS_ENV_ROLLBACKTRANS	10
 
 /* string types */
 #define TDS_NULLTERM -9
 
 /* Microsoft internal stored procedure id's */
 
 #define TDS_SP_CURSOR           1
 #define TDS_SP_CURSOROPEN       2
 #define TDS_SP_CURSORPREPARE    3
 #define TDS_SP_CURSOREXECUTE    4
@@ -1089,29 +1092,30 @@
 	, TDS_DBG_CONFIG = (1 << 7)	/**< replaces TDSDUMPCONFIG */
 	, TDS_DBG_DEFAULT = 0xFE	/**< all above except login packets */
 };
 
 typedef struct tds_result_info TDSCOMPUTEINFO;
 
 typedef TDSRESULTINFO TDSPARAMINFO;
 
 typedef struct tds_message
 {
-	TDS_SMALLINT priv_msg_type;
-	TDS_SMALLINT line_number;
-	TDS_UINT msgno;
-	TDS_SMALLINT state;
-	TDS_SMALLINT severity;
 	TDS_CHAR *server;
 	TDS_CHAR *message;
 	TDS_CHAR *proc_name;
 	TDS_CHAR *sql_state;
+	TDS_UINT msgno;
+	TDS_INT line_number;
+	/* -1 .. 255 */
+	TDS_SMALLINT state;
+	TDS_TINYINT priv_msg_type;
+	TDS_TINYINT severity;
 } TDSMESSAGE;
 
 typedef struct tds_upd_col
 {
 	struct tds_upd_col *next;	
 	TDS_INT colnamelength;
 	char * columnname;
 } TDSUPDCOL;
 
 typedef enum {
@@ -1303,40 +1307,41 @@
 	TDSCOMPUTEINFO **comp_info;
 	TDSPARAMINFO *param_info;
 	TDSCURSOR *cur_cursor;	/**< cursor in use */
 	TDSCURSOR *cursors;	/**< linked list of cursors allocated for this connection */
 	TDS_TINYINT has_status; /**< true is ret_status is valid */
 	TDS_INT ret_status;     /**< return status from store procedure */
 	TDS_STATE state;
 	/** indicate we are waiting a cancel reply so discard tokens till acknowledge */
 	volatile unsigned char in_cancel;
 	/** rows updated/deleted/inserted/selected, TDS_NO_COUNT if not valid */
-	int rows_affected;
+	TDS_INT8 rows_affected;
 	/* timeout stuff from Jeff */
 	TDS_INT query_timeout;
 	TDSENV env;
 
 	/* dynamic placeholder stuff */
 	/*@dependent@*/ TDSDYNAMIC *cur_dyn;	/**< dynamic structure in use */
 	TDSDYNAMIC *dyns;	/**< list of dynamic allocate for this connection */
 
 	int emul_little_endian;
 	char *date_fmt;
 	const TDSCONTEXT *tds_ctx;
 	int char_conv_count;
 	TDSICONV **char_convs;
 
 	/** config for login stuff. After login this field is NULL */
 	TDSCONNECTION *connection;
 
 	int spid;
 	TDS_UCHAR collation[5];
+	TDS_UCHAR tds9_transaction[8];
 	void (*env_chg_func) (TDSSOCKET * tds, int type, char *oldval, char *newval);
 	int internal_sp_called;
 
 	void *tls_session;
 	void *tls_credentials;
 	int option_value;
 };
 
 int tds_init_write_buf(TDSSOCKET * tds);
 void tds_free_result_info(TDSRESULTINFO * info);
@@ -1497,20 +1502,21 @@
 /* write.c */
 int tds_flush_packet(TDSSOCKET * tds);
 int tds_put_buf(TDSSOCKET * tds, const unsigned char *buf, int dsize, int ssize);
 
 /* read.c */
 unsigned char tds_get_byte(TDSSOCKET * tds);
 void tds_unget_byte(TDSSOCKET * tds);
 unsigned char tds_peek(TDSSOCKET * tds);
 TDS_SMALLINT tds_get_smallint(TDSSOCKET * tds);
 TDS_INT tds_get_int(TDSSOCKET * tds);
+TDS_INT8 tds_get_int8(TDSSOCKET * tds);
 int tds_get_string(TDSSOCKET * tds, int string_len, char *dest, size_t dest_size);
 int tds_get_char_data(TDSSOCKET * tds, char *dest, size_t wire_size, TDSCOLUMN * curcol);
 void *tds_get_n(TDSSOCKET * tds, /*@out@*/ /*@null@*/ void *dest, int n);
 int tds_get_size_by_type(int servertype);
 
 
 /* util.c */
 int tdserror (const TDSCONTEXT * tds_ctx, TDSSOCKET * tds, int msgno, int errnum);
 TDS_STATE tds_set_state(TDSSOCKET * tds, TDS_STATE state);
 void tds_set_parent(TDSSOCKET * tds, void *the_parent);
Index: include/tdsodbc.h
===================================================================
RCS file: /cvsroot/freetds/freetds/include/tdsodbc.h,v
retrieving revision 1.101
diff -u -1 -0 -r1.101 tdsodbc.h
--- include/tdsodbc.h	25 Aug 2007 10:33:29 -0000	1.101
+++ include/tdsodbc.h	18 Oct 2007 08:22:16 -0000
@@ -337,21 +337,21 @@
 	int param_num;
 	/** position in prepared query to check parameters, used only in RPC */
 	char *prepared_pos;
 
 	unsigned int curr_param_row, num_param_rows;
 
 	/** number of parameter in current query */
 	unsigned int param_count;
 	int row;
 	/** row count to return */
-	int row_count;
+	TDS_INT8 row_count;
 	/** status of row, it can happen that this flag mark that we are still parsing row, this it's normal */
 	TDS_ODBC_ROW_STATUS row_status;
 	/* do NOT free dynamic, free from socket or attach to connection */
 	TDSDYNAMIC *dyn;
 	struct _sql_errors errs;
 	TDS_DESC *ard, *ird, *apd, *ipd;
 	TDS_DESC *orig_ard, *orig_apd;
 	SQLULEN sql_rowset_size;
 	struct _hsattr attr;
 	DSTR cursor_name;	/* auto generated cursor name */
Index: src/ctlib/blk.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/ctlib/blk.c,v
retrieving revision 1.39
diff -u -1 -0 -r1.39 blk.c
--- src/ctlib/blk.c	16 Oct 2007 15:12:19 -0000	1.39
+++ src/ctlib/blk.c	18 Oct 2007 08:22:17 -0000
@@ -1060,21 +1060,24 @@
 		/*
 		 * dont send the (meta)data for timestamp columns, or
 		 * identity columns (unless indentity_insert is enabled
 		 */
 
 		if ((!blkdesc->identity_insert_on && bcpcol->column_identity) || 
 			bcpcol->column_timestamp) {
 			continue;
 		}
 
-		tds_put_smallint(tds, bcpcol->column_usertype);
+		if (IS_TDS90(tds))
+			tds_put_int(tds, bcpcol->column_usertype);
+		else
+			tds_put_smallint(tds, bcpcol->column_usertype);
 		tds_put_smallint(tds, bcpcol->column_flags);
 		tds_put_byte(tds, bcpcol->on_server.column_type);
 
 		switch (bcpcol->column_varint_size) {
 		case 4:
 			tds_put_int(tds, bcpcol->column_size);
 			break;
 		case 2:
 			tds_put_smallint(tds, bcpcol->column_size);
 			break;
Index: src/ctlib/ct.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/ctlib/ct.c,v
retrieving revision 1.175
diff -u -1 -0 -r1.175 ct.c
--- src/ctlib/ct.c	16 Oct 2007 15:12:20 -0000	1.175
+++ src/ctlib/ct.c	18 Oct 2007 08:22:19 -0000
@@ -2368,20 +2368,21 @@
 				curcol = resinfo->columns[i];
 				if (!curcol->column_hidden) {
 					int_val++;
 				}
 			}
 		}
 		tdsdump_log(TDS_DBG_FUNC, "ct_res_info(): Number of columns is %d\n", int_val);
 		memcpy(buffer, &int_val, sizeof(CS_INT));
 		break;
 	case CS_ROW_COUNT:
+		/* TODO 64 -> 32 bit conversion check overflow */
 		int_val = tds->rows_affected;
 		tdsdump_log(TDS_DBG_FUNC, "ct_res_info(): Number of rows is %d\n", int_val);
 		memcpy(buffer, &int_val, sizeof(CS_INT));
 		break;
 	default:
 		fprintf(stderr, "Unknown type in ct_res_info: %d\n", type);
 		return CS_FAIL;
 		break;
 	}
 	return CS_SUCCEED;
Index: src/dblib/bcp.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/dblib/bcp.c,v
retrieving revision 1.157
diff -u -1 -0 -r1.157 bcp.c
--- src/dblib/bcp.c	16 Oct 2007 15:12:20 -0000	1.157
+++ src/dblib/bcp.c	18 Oct 2007 08:22:21 -0000
@@ -2544,21 +2544,24 @@
 	/*
 	 * dont send the (meta)data for timestamp columns, or
 	 * identity columns (unless indentity_insert is enabled
 	 */
 
         if ((!dbproc->bcpinfo->identity_insert_on && bcpcol->column_identity) ||
             bcpcol->column_timestamp) {
             continue;
         }
 
-		tds_put_smallint(tds, bcpcol->column_usertype);
+		if (IS_TDS90(tds))
+			tds_put_int(tds, bcpcol->column_usertype);
+		else
+			tds_put_smallint(tds, bcpcol->column_usertype);
 		tds_put_smallint(tds, bcpcol->column_flags);
 		tds_put_byte(tds, bcpcol->on_server.column_type);
 
 		switch (bcpcol->column_varint_size) {
 		case 4:
 			tds_put_int(tds, bcpcol->column_size);
 			break;
 		case 2:
 			tds_put_smallint(tds, bcpcol->column_size);
 			break;
Index: src/dblib/dblib.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/dblib/dblib.c,v
retrieving revision 1.291
diff -u -1 -0 -r1.291 dblib.c
--- src/dblib/dblib.c	16 Oct 2007 15:12:20 -0000	1.291
+++ src/dblib/dblib.c	18 Oct 2007 08:22:27 -0000
@@ -458,21 +458,21 @@
 		break;
 	case DBSETPWD:
 		tds_set_passwd(login->tds_login, value);
 		return SUCCEED;
 		break;
 	case DBSETAPP:
 		tds_set_app(login->tds_login, value);
 		return SUCCEED;
 		break;
 	case DBSETCHARSET:
-		tds_set_client_charset(login->tds_login, value);
+		tds_set_client_charset(login->tds_login, value ? value : "");
 		return SUCCEED;
 		break;
 	case DBSETNATLANG:
 		tds_set_language(login->tds_login, value);
 		return SUCCEED;
 		break;
 	case DBSETHID:
 	default:
 		dbperror(NULL, SYBEASUL, 0); /* Attempt to set unknown LOGINREC field */
 		return FAIL;
Index: src/odbc/odbc.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/odbc/odbc.c,v
retrieving revision 1.456
diff -u -1 -0 -r1.456 odbc.c
--- src/odbc/odbc.c	16 Oct 2007 15:12:21 -0000	1.456
+++ src/odbc/odbc.c	18 Oct 2007 08:22:31 -0000
@@ -594,35 +594,35 @@
 		stmt->row_status = IN_COMPUTE_ROW;
 		in_row = 1;
 	}
 
 	param_status = SQL_PARAM_SUCCESS;
 	token_flags = (TDS_TOKEN_RESULTS & (~TDS_STOPAT_COMPUTE)) | TDS_RETURN_COMPUTE;
 	if (stmt->dbc->env->attr.odbc_version == SQL_OV_ODBC3)
 		token_flags |= TDS_RETURN_MSG;
 	for (;;) {
 		result_type = odbc_process_tokens(stmt, token_flags);
-		tdsdump_log(TDS_DBG_INFO1, "SQLMoreResults: result_type=%d, row_count=%d, lastrc=%d\n", 
+		tdsdump_log(TDS_DBG_INFO1, "SQLMoreResults: result_type=%d, row_count=%" TDS_I64_FORMAT ", lastrc=%d\n", 
 						result_type, stmt->row_count, stmt->errs.lastrc);
 		switch (result_type) {
 		case TDS_CMD_DONE:
 			if (stmt->dbc->current_statement == stmt)
 				stmt->dbc->current_statement = NULL;
 #if 1 /* !UNIXODBC */
 			tds_free_all_results(tds);
 #endif
 			odbc_populate_ird(stmt);
 			if (stmt->row_count == TDS_NO_COUNT && !in_row) {
 				stmt->row_status = NOT_IN_ROW;
 				tdsdump_log(TDS_DBG_INFO1, "SQLMoreResults: row_status=%d\n", stmt->row_status);
 			}
-			tdsdump_log(TDS_DBG_INFO1, "SQLMoreResults: row_count=%d, lastrc=%d\n", stmt->row_count, stmt->errs.lastrc);
+			tdsdump_log(TDS_DBG_INFO1, "SQLMoreResults: row_count=%" TDS_I64_FORMAT ", lastrc=%d\n", stmt->row_count, stmt->errs.lastrc);
 			if (stmt->row_count == TDS_NO_COUNT) {
 				if (stmt->errs.lastrc == SQL_SUCCESS || stmt->errs.lastrc == SQL_SUCCESS_WITH_INFO)
 					ODBC_RETURN(stmt, SQL_NO_DATA);
 			}
 			ODBC_RETURN_(stmt);
 
 		case TDS_CMD_FAIL:
 			ODBC_SAFE_ERROR(stmt);
 			ODBC_RETURN(stmt, SQL_ERROR);
 
@@ -3262,21 +3262,21 @@
 			/* test for internal_sp not very fine, used for param set  -- freddy77 */
 			if ((done_flags & (TDS_DONE_COUNT|TDS_DONE_ERROR)) != 0
 			    || (stmt->errs.lastrc == SQL_SUCCESS_WITH_INFO && stmt->dbc->env->attr.odbc_version == SQL_OV_ODBC3)
 			    || (result_type == TDS_DONEPROC_RESULT && tds->internal_sp_called == TDS_SP_EXECUTE)) {
 				/* FIXME this row is used only as a flag for update binding, should be cleared if binding/result changed */
 				stmt->row = 0;
 #if 0
 				tds_free_all_results(tds);
 				odbc_populate_ird(stmt);
 #endif
-				tdsdump_log(TDS_DBG_FUNC, "odbc_process_tokens: row_count=%d\n", stmt->row_count);
+				tdsdump_log(TDS_DBG_FUNC, "odbc_process_tokens: row_count=%" TDS_I64_FORMAT "\n", stmt->row_count);
 				return result_type;
 			}
 			tdsdump_log(TDS_DBG_FUNC, "odbc_process_tokens: processed %s\n", 
 					result_type==TDS_DONE_RESULT? "TDS_DONE_RESULT" : "TDS_DONEPROC_RESULT");
 			break;
 
 		/*
 		 * TODO test flags ? check error and change result ?
 		 * see also other DONEINPROC handle (below)
 		 */
Index: src/server/server.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/server/server.c,v
retrieving revision 1.22
diff -u -1 -0 -r1.22 server.c
--- src/server/server.c	24 Sep 2007 10:02:14 -0000	1.22
+++ src/server/server.c	18 Oct 2007 08:22:31 -0000
@@ -219,21 +219,24 @@
  *			TDS_DONE_CANCELLED if the query was canceled, and
  *			TDS_DONE_EVENT if the token marks an event.
  * \param numrows	Number of rows, if flags has TDS_DONE_COUNT.
  */
 void
 tds_send_done(TDSSOCKET * tds, int token, TDS_SMALLINT flags, TDS_INT numrows)
 {
 	tds_put_byte(tds, token);
 	tds_put_smallint(tds, flags);
 	tds_put_smallint(tds, 2); /* are these two bytes the transaction status? */
-	tds_put_int(tds, numrows);
+	if (IS_TDS90(tds))
+		tds_put_int8(tds, numrows);
+	else
+		tds_put_int(tds, numrows);
 }
 
 void
 tds_send_done_token(TDSSOCKET * tds, TDS_SMALLINT flags, TDS_INT numrows)
 {
 	tds_send_done(tds, TDS_DONE_TOKEN, flags, numrows);
 }
 
 void
 tds_send_control_token(TDSSOCKET * tds, TDS_SMALLINT numcols)
@@ -403,20 +406,21 @@
 		tds_send_col_info(tds, resinfo);
 		break;
 
 	case 5:
 		/* TDS5 uses a TDS_RESULT_TOKEN to send all column information */
 		tds_send_result(tds, resinfo);
 		break;
 
 	case 7:
 	case 8:
+	case 9:
 		/*
 		 * TDS7+ uses a TDS7_RESULT_TOKEN to send all column
 		 * information.
 		 */
 		tds7_send_result(tds, resinfo);
 		break;
 	}
 }
 
 void
Index: src/tds/config.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/tds/config.c,v
retrieving revision 1.129
diff -u -1 -0 -r1.129 config.c
--- src/tds/config.c	8 Aug 2007 09:13:29 -0000	1.129
+++ src/tds/config.c	18 Oct 2007 08:22:31 -0000
@@ -1,12 +1,13 @@
 /* FreeTDS - Library of routines accessing Sybase and Microsoft databases
  * Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005  Brian Bruns
+ * Copyright (C) 2006, 2007  Frediano Ziglio
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
  * License as published by the Free Software Foundation; either
  * version 2 of the License, or (at your option) any later version.
  *
  * This library is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Library General Public License for more details.
@@ -675,20 +676,24 @@
 		connection->minor_version = 0;
 		return;
 	} else if (!strcmp(tdsver, "70") || !strcmp(tdsver, "7.0")) {
 		connection->major_version = 7;
 		connection->minor_version = 0;
 		return;
 	} else if (!strcmp(tdsver, "80") || !strcmp(tdsver, "8.0")) {
 		connection->major_version = 8;
 		connection->minor_version = 0;
 		return;
+	} else if (!strcmp(tdsver, "90") || !strcmp(tdsver, "9.0")) {
+		connection->major_version = 9;
+		connection->minor_version = 0;
+		return;
 	} else if (!strcmp(tdsver, "0.0")) {
 		connection->major_version = 0;
 		connection->minor_version = 0;
 		return;
 	}
 }
 
 /**
  * Set the full name of interface file
  * @param interf file name
Index: src/tds/login.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/tds/login.c,v
retrieving revision 1.163
diff -u -1 -0 -r1.163 login.c
--- src/tds/login.c	16 Oct 2007 15:12:22 -0000	1.163
+++ src/tds/login.c	18 Oct 2007 08:22:31 -0000
@@ -751,20 +751,21 @@
  */
 static int
 tds7_send_login(TDSSOCKET * tds, TDSCONNECTION * connection)
 {
 	int rc;
 
 	static const unsigned char client_progver[] = { 6, 0x83, 0xf2, 0xf8 };
 
 	static const unsigned char tds7Version[] = { 0x00, 0x00, 0x00, 0x70 };
 	static const unsigned char tds8Version[] = { 0x01, 0x00, 0x00, 0x71 };
+	static const unsigned char tds9Version[] = { 0x02, 0x00, 0x09, 0x72 };
 
 	static const unsigned char connection_id[] = { 0x00, 0x00, 0x00, 0x00 };
 	unsigned char option_flag1 = 0x00;
 	unsigned char option_flag2 = tds->option_flag2;
 	static const unsigned char sql_type_flag = 0x00;
 	static const unsigned char reserved_flag = 0x00;
 
 	static const unsigned char time_zone[] = { 0x88, 0xff, 0xff, 0xff };
 	static const unsigned char collation[] = { 0x36, 0x04, 0x00, 0x00 };
 
@@ -804,29 +805,33 @@
 	if ((p = strchr(user_name, '\\')) != NULL) {
 		domain = user_name;
 		domain_len = p - user_name;
 
 		user_name = p + 1;
 		user_name_len = strlen(user_name);
 
 		domain_login = 1;
 	}
 
-	packet_size = 86 + (host_name_len + app_name_len + server_name_len + library_len + language_len + database_len) * 2;
+	current_pos = IS_TDS90(tds) ? 86 + 8 : 86;	/* ? */
+
+	packet_size = current_pos + (host_name_len + app_name_len + server_name_len + library_len + language_len + database_len) * 2;
 	if (domain_login) {
 		auth_len = 32 + host_name_len + domain_len;
 		packet_size += auth_len;
 	} else
 		packet_size += (user_name_len + password_len) * 2;
 
 	tds_put_int(tds, packet_size);
-	if (IS_TDS8_PLUS(tds)) {
+	if (IS_TDS90(tds)) {
+		tds_put_n(tds, tds9Version, 4);
+	} else if (IS_TDS8_PLUS(tds)) {
 		tds_put_n(tds, tds8Version, 4);
 	} else {
 		tds_put_n(tds, tds7Version, 4);
 	}
 
 	if (connection->block_size < 1000000)
 		block_size = connection->block_size;
 	else
 		block_size = 4096;	/* SQL server default */
 	tds_put_int(tds, block_size);	/* desired packet size being requested by client */
@@ -847,21 +852,20 @@
 		option_flag2 |= 0x80;	/* enable domain login security                     */
 
 	tds_put_byte(tds, option_flag2);
 
 	tds_put_byte(tds, sql_type_flag);
 	tds_put_byte(tds, reserved_flag);
 
 	tds_put_n(tds, time_zone, 4);
 	tds_put_n(tds, collation, 4);
 
-	current_pos = 86;	/* ? */
 	/* host name */
 	tds_put_smallint(tds, current_pos);
 	tds_put_smallint(tds, host_name_len);
 	current_pos += host_name_len * 2;
 	if (domain_login) {
 		tds_put_smallint(tds, 0);
 		tds_put_smallint(tds, 0);
 		tds_put_smallint(tds, 0);
 		tds_put_smallint(tds, 0);
 	} else {
@@ -907,20 +911,27 @@
 	if (domain_login) {
 		tds_put_smallint(tds, auth_len);	/* this matches numbers at end of packet */
 		current_pos += auth_len;
 	} else
 		tds_put_smallint(tds, 0);
 
 	/* unknown */
 	tds_put_smallint(tds, current_pos);
 	tds_put_smallint(tds, 0);
 
+	if (IS_TDS90(tds)) {
+		tds_put_smallint(tds, current_pos);
+		tds_put_smallint(tds, 0);
+
+		tds_put_int(tds, 0);
+	}
+
 	/* FIXME here we assume single byte, do not use *2 to compute bytes, convert before !!! */
 	tds_put_string(tds, tds_dstr_cstr(&connection->client_host_name), host_name_len);
 	if (!domain_login) {
 		TDSICONV *char_conv = tds->char_convs[client2ucs2];
 		tds_put_string(tds, tds_dstr_cstr(&connection->user_name), user_name_len);
 		p = tds_dstr_cstr(&connection->password);
 		punicode = unicode_string;
 		unicode_left = sizeof(unicode_string);
 
 		memset(&char_conv->suppress, 0, sizeof(char_conv->suppress));
@@ -998,65 +1009,70 @@
 	/*
 	 * In case we do not have SSL enabled do not send pre-login so
 	 * if server has certificate but no force encryption login success
 	 */
 	return tds7_send_login(tds, connection);
 #else
 	int i, len, ret;
 	const char *instance_name = tds_dstr_isempty(&connection->instance_name) ? "MSSQLServer" : tds_dstr_cstr(&connection->instance_name);
 	int instance_name_len = strlen(instance_name) + 1;
 	TDS_CHAR crypt_flag;
-#define START_POS 21
+#define START_POS 26
 #define UI16BE(n) ((n) >> 8), ((n) & 0xffu)
 #define SET_UI16BE(i,n) do { buf[i] = ((n) >> 8); buf[i+1] = ((n) & 0xffu); } while(0)
 	TDS_UCHAR buf[] = {
 		/* netlib version */
 		0, UI16BE(START_POS), UI16BE(6),
 		/* encryption */
 		1, UI16BE(START_POS + 6), UI16BE(1),
 		/* instance */
 		2, UI16BE(START_POS + 6 + 1), UI16BE(0),
 		/* process id */
 		3, UI16BE(0), UI16BE(4),
+		/* ???? unknown ??? */
+		4, UI16BE(0), UI16BE(1),
 		/* end */
 		0xff,
 		/* netlib value */
-		8, 0, 1, 0x55, 0, 0,
+		9, 0, 0, 0, 0, 0,
 		/* encryption, normal */
 		0
 	};
 
 	TDS_UCHAR *p;
 
 	SET_UI16BE(13, instance_name_len);
 	SET_UI16BE(16, START_POS + 6 + 1 + instance_name_len);
+	SET_UI16BE(21, START_POS + 6 + 1 + instance_name_len + 4);
 	if (connection->encryption_level)
 		buf[sizeof(buf)-1] = 1;
 
 	assert(sizeof(buf) == START_POS + 7);
 
 	/* do prelogin */
 	tds->out_flag = TDS8_PRELOGIN;
 
 	tds_put_n(tds, buf, sizeof(buf));
 	tds_put_n(tds, instance_name, instance_name_len);
 	tds_put_int(tds, getpid());
+	tds_put_byte(tds, 0);
 	if (tds_flush_packet(tds) == TDS_FAIL)
 		return TDS_FAIL;
 
 	/* now process reply from server */
 	len = tds_read_packet(tds);
 	if (len <= 0 || tds->in_flag != 4)
 		return TDS_FAIL;
+	len = tds->in_len - tds->in_pos;
 
 	/* the only thing we care is flag */
-	p = tds->in_buf;
+	p = tds->in_buf + tds->in_pos;
 	/* default 2, no certificate, no encryption */
 	crypt_flag = 2;
 	for (i = 0;; i += 5) {
 		TDS_UCHAR type;
 		int off, l;
 
 		if (i >= len)
 			return TDS_FAIL;
 		type = p[i];
 		if (type == 0xff)
Index: src/tds/net.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/tds/net.c,v
retrieving revision 1.66
diff -u -1 -0 -r1.66 net.c
--- src/tds/net.c	17 Sep 2007 21:27:26 -0000	1.66
+++ src/tds/net.c	18 Oct 2007 08:22:33 -0000
@@ -578,21 +578,21 @@
 			 */
 			tds->in_len = 0;
 			tds->in_pos = 0;
 			tds->last_packet = 1;
 			return (-1);
 		}
 	}
 #endif
 
 	/* Convert our packet length from network to host byte order */
-	len = ((((unsigned int) header[2]) << 8) | header[3]) - 8;
+	len = (((unsigned int) header[2]) << 8) | header[3];
 
 	/*
 	 * If this packet size is the largest we have gotten allocate space for it
 	 */
 	if (len > tds->in_buf_max) {
 		unsigned char *p;
 
 		if (!tds->in_buf) {
 			p = (unsigned char *) malloc(len);
 		} else {
@@ -602,23 +602,24 @@
 			tds_close_socket(tds);
 			return -1;
 		}
 		tds->in_buf = p;
 		/* Set the new maximum packet size */
 		tds->in_buf_max = len;
 	}
 
 	/* Clean out the in_buf so we don't use old stuff by mistake */
 	memset(tds->in_buf, 0, tds->in_buf_max);
+	memcpy(tds->in_buf, header, 8);
 
 	/* Now get exactly how many bytes the server told us to get */
-	have = 0;
+	have = 8;
 	while (have < len) {
 		int nbytes = goodread(tds, tds->in_buf + have, len - have);
 		if (nbytes < 1) {
 			/*
 			 * Not sure if this is the best way to do the error
 			 * handling here but this is the way it is currently
 			 * being done.
 			 */
 			/* no need to call tdserror(), because goodread() already did */
 			tds->in_len = 0;
@@ -631,21 +632,21 @@
 	}
 
 	/* Set the last packet flag */
 	tds->last_packet = (header[1] != 0);
 
 	/* set the received packet type flag */
 	tds->in_flag = header[0];
 
 	/* Set the length and pos (not sure what pos is used for now */
 	tds->in_len = have;
-	tds->in_pos = 0;
+	tds->in_pos = 8;
 	tdsdump_dump_buf(TDS_DBG_NETWORK, "Received packet", tds->in_buf, tds->in_len);
 
 	return (tds->in_len);
 }
 
 /**
  * \param tds the famous socket
  * \param p pointer to buffer
  * \param len bytes in buffer
  * \param last 1 if this is the last packet, else 0
Index: src/tds/query.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/tds/query.c,v
retrieving revision 1.211
diff -u -1 -0 -r1.211 query.c
--- src/tds/query.c	16 Oct 2007 15:12:22 -0000	1.211
+++ src/tds/query.c	18 Oct 2007 08:22:33 -0000
@@ -58,20 +58,22 @@
 
 static int tds_send_emulated_execute(TDSSOCKET * tds, const char *query, TDSPARAMINFO * params);
 static const char *tds_skip_comment(const char *s);
 static int tds_count_placeholders_ucs2le(const char *query, const char *query_end);
 
 #define TDS_PUT_DATA_USE_NAME 1
 #define TDS_PUT_DATA_PREFIX_NAME 2
 
 #undef MIN
 #define MIN(a,b) (((a) < (b)) ? (a) : (b))
+#undef MAX
+#define MAX(a,b) (((a) > (b)) ? (a) : (b))
 
 /* All manner of client to server submittal functions */
 
 /**
  * \ingroup libtds
  * \defgroup query Query
  * Function to handle query.
  */
 
 /**
@@ -225,20 +227,47 @@
 		sprintf(params->columns[i]->column_name, "@P%d", i + 1);
 		params->columns[i]->column_namelen = strlen(params->columns[i]->column_name);
 
 		s = e + 1;
 	}
 	out[pos] = 0;
 	*query_len = pos;
 	return out;
 }
 
+static const TDS_UCHAR tds9_query_start[] = {
+	/* total length */
+	0x16, 0, 0, 0,
+	/* length */
+	0x12, 0, 0, 0,
+	/* type */
+	0x02, 0,
+	/* transaction */
+	0, 0, 0, 0, 0, 0, 0, 0,
+	/* request count */
+	1, 0, 0, 0
+};
+
+#define START_QUERY \
+do { \
+	if (IS_TDS90(tds)) \
+		tds_start_query(tds); \
+} while(0)
+
+static void
+tds_start_query(TDSSOCKET *tds)
+{
+	tds_put_n(tds, tds9_query_start, 10);
+	tds_put_n(tds, tds->tds9_transaction, 8);
+	tds_put_n(tds, tds9_query_start + 10 + 8, 4);
+}
+
 /**
  * tds_submit_query_params() sends a language string to the database server for
  * processing.  TDS 4.2 is a plain text message with a packet type of 0x01,
  * TDS 7.0 is a unicode string with packet type 0x01, and TDS 5.0 uses a
  * TDS_LANGUAGE_TOKEN to encapsulate the query and a packet type of 0x0f.
  * \param tds state information for the socket and the TDS protocol
  * \param query  language query to submit
  * \param params parameters of query
  * \return TDS_FAIL or TDS_SUCCEED
  */
@@ -274,24 +303,24 @@
 		tds->out_flag = TDS_NORMAL;
 		tds_put_byte(tds, TDS_LANGUAGE_TOKEN);
 		/* TODO ICONV use converted size, not input size and convert string */
 		tds_put_int(tds, query_len + 1);
 		tds_put_byte(tds, params ? 1 : 0);  /* 1 if there are params, 0 otherwise */
 		tds_put_n(tds, query, query_len);
 		if (params) {
 			/* add on parameters */
 			tds_put_params(tds, params, params->columns[0]->column_name[0] ? TDS_PUT_DATA_USE_NAME : 0);
 		}
-		if (new_query)
-			free(new_query);
+		free(new_query);
 	} else if (!IS_TDS7_PLUS(tds) || !params || !params->num_cols) {
 		tds->out_flag = TDS_QUERY;
+		START_QUERY;
 		tds_put_string(tds, query, query_len);
 	} else {
 		TDSCOLUMN *param;
 		int definition_len, count, i;
 		char *param_definition;
 		int converted_query_len;
 		const char *converted_query;
  
 		converted_query = tds_convert_string(tds, tds->char_convs[client2ucs2], query, query_len, &converted_query_len);
 		if (!converted_query) {
@@ -314,20 +343,21 @@
 			 * should call also tds7_build_param_def_from_params ??
 			 */
 			param_definition = tds7_build_param_def_from_query(tds, converted_query, converted_query_len, params, &definition_len);
 			if (!param_definition) {
 				tds_set_state(tds, TDS_IDLE);
 				return TDS_FAIL;
 			}
 		}
  
 		tds->out_flag = TDS_RPC;
+		START_QUERY;
 		/* procedure name */
 		if (IS_TDS8_PLUS(tds)) {
 			tds_put_smallint(tds, -1);
 			tds_put_smallint(tds, TDS_SP_EXECUTESQL);
 		} else {
 			tds_put_smallint(tds, 13);
 			TDS_PUT_N_AS_UCS2(tds, "sp_executesql");
 		}
 		tds_put_smallint(tds, 0);
  
@@ -1019,20 +1049,21 @@
 		if (!converted_query)
 			goto failure;
 
 		param_definition = tds7_build_param_def_from_query(tds, converted_query, converted_query_len, params, &definition_len);
 		if (!param_definition) {
 			tds_convert_string_free(query, converted_query);
 			goto failure;
 		}
 
 		tds->out_flag = TDS_RPC;
+		START_QUERY;
 		/* procedure name */
 		if (IS_TDS8_PLUS(tds)) {
 			tds_put_smallint(tds, -1);
 			tds_put_smallint(tds, TDS_SP_PREPARE);
 		} else {
 			tds_put_smallint(tds, 10);
 			TDS_PUT_N_AS_UCS2(tds, "sp_prepare");
 		}
 		tds_put_smallint(tds, 0);
 
@@ -1132,20 +1163,21 @@
 		}
 
 		param_definition = tds7_build_param_def_from_query(tds, converted_query, converted_query_len, params, &definition_len);
 		if (!param_definition) {
 			tds_convert_string_free(query, converted_query);
 			tds_set_state(tds, TDS_IDLE);
 			return TDS_FAIL;
 		}
 
 		tds->out_flag = TDS_RPC;
+		START_QUERY;
 		/* procedure name */
 		if (IS_TDS8_PLUS(tds)) {
 			tds_put_smallint(tds, -1);
 			tds_put_smallint(tds, TDS_SP_EXECUTESQL);
 		} else {
 			tds_put_smallint(tds, 13);
 			TDS_PUT_N_AS_UCS2(tds, "sp_executesql");
 		}
 		tds_put_smallint(tds, 0);
 
@@ -1299,27 +1331,27 @@
 		TDS_NUMERIC *num = (TDS_NUMERIC *) curcol->column_data;
 		tds_put_byte(tds, tds_numeric_bytes_per_prec[num->precision]);
 		tds_put_byte(tds, num->precision);
 		tds_put_byte(tds, num->scale);
 #endif
 	} else {
 		switch (curcol->column_varint_size) {
 		case 0:
 			break;
 		case 1:
-			tds_put_byte(tds, MIN(curcol->column_size, 255));
+			tds_put_byte(tds, MAX(MIN(curcol->column_size, 255), 1));
 			break;
 		case 2:
-			tds_put_smallint(tds, MIN(curcol->column_size, 8000));
+			tds_put_smallint(tds, MAX(MIN(curcol->column_size, 8000), 1));
 			break;
 		case 4:
-			tds_put_int(tds, MIN(curcol->column_size, 0x7fffffff));
+			tds_put_int(tds, MAX(MIN(curcol->column_size, 0x7fffffff), 1));
 			break;
 		}
 	}
 
 	/* TDS8 output collate information */
 	if (IS_TDS8_PLUS(tds) && is_collate_type(curcol->on_server.column_type))
 		tds_put_n(tds, tds->collation, 5);
 
 	/* TODO needed in TDS4.2 ?? now is called only is TDS >= 5 */
 	if (!IS_TDS7_PLUS(tds)) {
@@ -1598,20 +1630,21 @@
 
 	if (IS_TDS7_PLUS(tds)) {
 		/* check proper id */
 		if (dyn->num_id == 0) {
 			tds_set_state(tds, TDS_IDLE);
 			return TDS_FAIL;
 		}
 
 		/* RPC on sp_execute */
 		tds->out_flag = TDS_RPC;
+		START_QUERY;
 
 		tds7_send_execute(tds, dyn);
 
 		return tds_query_flush_packet(tds);
 	}
 
 	if (dyn->emulated) {
 		if (tds_send_emulated_execute(tds, dyn->query, dyn->params) != TDS_SUCCEED)
 			return TDS_FAIL;
 		return tds_query_flush_packet(tds);
@@ -1728,20 +1761,21 @@
 	tdsdump_log(TDS_DBG_FUNC, "tds_submit_unprepare() %s\n", dyn->id);
 
 	if (tds_set_state(tds, TDS_QUERYING) != TDS_QUERYING)
 		return TDS_FAIL;
 
 	tds->cur_dyn = dyn;
 
 	if (IS_TDS7_PLUS(tds)) {
 		/* RPC on sp_execute */
 		tds->out_flag = TDS_RPC;
+		START_QUERY;
 		/* procedure name */
 		if (IS_TDS8_PLUS(tds)) {
 			/* save some byte for mssql2k */
 			tds_put_smallint(tds, -1);
 			tds_put_smallint(tds, TDS_SP_UNPREPARE);
 		} else {
 			tds_put_smallint(tds, 12);
 			TDS_PUT_N_AS_UCS2(tds, "sp_unprepare");
 		}
 		tds_put_smallint(tds, 0);	/* flags */
@@ -1753,20 +1787,21 @@
 		tds_put_byte(tds, 4);
 		tds_put_byte(tds, 4);
 		tds_put_int(tds, dyn->num_id);
 
 		tds->internal_sp_called = TDS_SP_UNPREPARE;
 		return tds_query_flush_packet(tds);
 	}
 
 	if (dyn->emulated) {
 		tds->out_flag = TDS_QUERY;
+		START_QUERY;
 		/* just a dummy select to return some data */
 		tds_put_string(tds, "select 1 where 0=1", -1);
 		return tds_query_flush_packet(tds);
 	}
 
 	tds->out_flag = TDS_NORMAL;
 	/* dynamic id */
 	id_len = strlen(dyn->id);
 
 	tds_put_byte(tds, TDS5_DYNAMIC_TOKEN);
@@ -1812,20 +1847,21 @@
 		const char *converted_name;
 		int converted_name_len;
 
 		tds->out_flag = TDS_RPC;
 		/* procedure name */
 		converted_name = tds_convert_string(tds, tds->char_convs[client2ucs2], rpc_name, rpc_name_len, &converted_name_len);
 		if (!converted_name) {
 			tds_set_state(tds, TDS_IDLE);
 			return TDS_FAIL;
 		}
+		START_QUERY;
 		tds_put_smallint(tds, converted_name_len / 2);
 		tds_put_n(tds, converted_name, converted_name_len);
 		tds_convert_string_free(rpc_name, converted_name);
 
 		/*
 		 * TODO support flags
 		 * bit 0 (1 as flag) in TDS7/TDS5 is "recompile"
 		 * bit 1 (2 as flag) in TDS7+ is "no metadata" bit 
 		 * (I don't know meaning of "no metadata")
 		 */
@@ -2089,20 +2125,21 @@
 						     cursor->query, strlen(cursor->query), &converted_query_len);
 		if (!converted_query) {
 			if (!*something_to_send)
 				tds_set_state(tds, TDS_IDLE);
 			return TDS_FAIL;
 		}
 
 		/* RPC call to sp_cursoropen */
 
 		tds->out_flag = TDS_RPC;
+		START_QUERY;
 
 		/* procedure identifier by number */
 
 		if (IS_TDS8_PLUS(tds)) {
 			tds_put_smallint(tds, -1);
 			tds_put_smallint(tds, TDS_SP_CURSOROPEN);
 		} else {
 			tds_put_smallint(tds, 13);
 			TDS_PUT_N_AS_UCS2(tds, "sp_cursoropen");
 		}
@@ -2313,26 +2350,28 @@
 			0,
 			2,    /* TDS_CURSOR_FETCH_NEXT */
 			4,    /* TDS_CURSOR_FETCH_PREV */
 			1,    /* TDS_CURSOR_FETCH_FIRST */
 			8,    /* TDS_CURSOR_FETCH_LAST */
 			0x10, /* TDS_CURSOR_FETCH_ABSOLUTE */
 			0x20  /* TDS_CURSOR_FETCH_RELATIVE */
 		};
 
 		tds->out_flag = TDS_RPC;
+		START_QUERY;
 
 		/* TODO enum for 2 ... */
 		if (cursor->type == 2 && fetch_type == TDS_CURSOR_FETCH_ABSOLUTE) {
 			/* strangely dynamic cursor do not support absolute so emulate it with first + relative */
 			tds7_put_cursor_fetch(tds, cursor->cursor_id, 1, 0, 0);
-			tds_put_byte(tds, 0x80);
+			/* TODO define constant */
+			tds_put_byte(tds, IS_TDS90(tds) ? 0xff : 0x80);
 			tds7_put_cursor_fetch(tds, cursor->cursor_id, 0x20, i_row, cursor->cursor_rows);
 		} else {
 			/* TODO check fetch_type ?? */
 			tds7_put_cursor_fetch(tds, cursor->cursor_id, mssql_fetch[fetch_type], i_row, cursor->cursor_rows);
 		}
 
 		tds->internal_sp_called = TDS_SP_CURSORFETCH;
 		return tds_query_flush_packet(tds);
 	}
 
@@ -2367,20 +2406,21 @@
 		}
 		else
 			tds_put_byte(tds, 0x00);	/* Close option: TDS_CUR_COPT_UNUSED */
 
 	}
 	if (IS_TDS7_PLUS(tds)) {
 
 		/* RPC call to sp_cursorclose */
 
 		tds->out_flag = TDS_RPC;
+		START_QUERY;
 
 		if (IS_TDS8_PLUS(tds)) {
 			tds_put_smallint(tds, -1);
 			tds_put_smallint(tds, TDS_SP_CURSORCLOSE);
 		} else {
 			tds_put_smallint(tds, 14);
 			TDS_PUT_N_AS_UCS2(tds, "sp_cursorclose");
 		}
 
 		/* This flag tells the SP to output only a dummy metadata token  */
@@ -2416,20 +2456,21 @@
 	if (!IS_TDS7_PLUS(tds))
 		return TDS_SUCCEED;
 
 	if (tds_set_state(tds, TDS_QUERYING) != TDS_QUERYING)
 		return TDS_FAIL;
 
 	tds_set_cur_cursor(tds, cursor);
 
 	/* RPC call to sp_cursoroption */
 	tds->out_flag = TDS_RPC;
+	START_QUERY;
 
 	if (IS_TDS8_PLUS(tds)) {
 		tds_put_smallint(tds, -1);
 		tds_put_smallint(tds, TDS_SP_CURSOROPTION);
 	} else {
 		tds_put_smallint(tds, 14);
 		TDS_PUT_N_AS_UCS2(tds, "sp_cursoroption");
 	}
 
 	tds_put_smallint(tds, 0);
@@ -2491,20 +2532,21 @@
 
 		/* FIXME finish*/
 		tds_set_state(tds, TDS_IDLE);
 		return TDS_FAIL;
 	}
 	if (IS_TDS7_PLUS(tds)) {
 
 		/* RPC call to sp_cursorclose */
 
 		tds->out_flag = TDS_RPC;
+		START_QUERY;
 
 		if (IS_TDS8_PLUS(tds)) {
 			tds_put_smallint(tds, -1);
 			tds_put_smallint(tds, TDS_SP_CURSOR);
 		} else {
 			tds_put_smallint(tds, 14);
 			TDS_PUT_N_AS_UCS2(tds, "sp_cursor");
 		}
 
 		tds_put_smallint(tds, 0);
@@ -2748,20 +2790,21 @@
 
 	num_placeholders = tds_count_placeholders(query);
 	if (num_placeholders && num_placeholders > params->num_cols)
 		return TDS_FAIL;
 	
 	/* 
 	 * NOTE: even for TDS5 we use this packet so to avoid computing 
 	 * entire sql command
 	 */
 	tds->out_flag = TDS_QUERY;
+	START_QUERY;
 	if (!num_placeholders) {
 		tds_put_string(tds, query, -1);
 		return tds_flush_packet(tds);
 	}
 
 	s = query;
 	for (i = 0;; ++i) {
 		e = tds_next_placeholder(s);
 		tds_put_string(tds, s, e ? e - s : -1);
 		if (!e)
@@ -2789,20 +2832,21 @@
 	tds->out_flag = TDS_QUERY;
 	switch (type) {
 	case TDS_MULTIPLE_QUERY:
 		break;
 	case TDS_MULTIPLE_EXECUTE:
 	case TDS_MULTIPLE_RPC:
 		if (IS_TDS7_PLUS(tds))
 			tds->out_flag = TDS_RPC;
 		break;
 	}
+	START_QUERY;
 
 	return TDS_SUCCEED;
 }
 
 int
 tds_multiple_done(TDSSOCKET *tds, TDSMULTIPLE *multiple)
 {
 	assert(tds && multiple);
 
 	return tds_query_flush_packet(tds);
@@ -2819,22 +2863,24 @@
 
 	return tds_send_emulated_execute(tds, query, params);
 }
 
 int
 tds_multiple_execute(TDSSOCKET *tds, TDSMULTIPLE *multiple, TDSDYNAMIC * dyn)
 {
 	assert(multiple->type == TDS_MULTIPLE_EXECUTE);
 
 	if (IS_TDS7_PLUS(tds)) {
-		if (multiple->flags & MUL_STARTED)
-			tds_put_byte(tds, 0x80);
+		if (multiple->flags & MUL_STARTED) {
+			/* TODO define constant */
+			tds_put_byte(tds, IS_TDS90(tds) ? 0xff : 0x80);
+		}
 		multiple->flags |= MUL_STARTED;
 
 		tds7_send_execute(tds, dyn);
 
 		return TDS_SUCCEED;
 	}
 
 	if (multiple->flags & MUL_STARTED)
 		tds_put_string(tds, " ", 1);
 	multiple->flags |= MUL_STARTED;
Index: src/tds/read.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/tds/read.c,v
retrieving revision 1.104
diff -u -1 -0 -r1.104 read.c
--- src/tds/read.c	6 Sep 2007 11:17:21 -0000	1.104
+++ src/tds/read.c	18 Oct 2007 08:22:33 -0000
@@ -129,20 +129,43 @@
 	unsigned char bytes[4];
 
 	tds_get_n(tds, bytes, 4);
 #if WORDS_BIGENDIAN
 	if (tds->emul_little_endian)
 		return (TDS_INT) TDS_GET_A4LE(bytes);
 #endif
 	return (TDS_INT) TDS_GET_A4(bytes);
 }
 
+TDS_INT8
+tds_get_int8(TDSSOCKET * tds)
+{
+	TDS_INT h;
+	TDS_UINT l;
+	unsigned char bytes[8];
+
+	tds_get_n(tds, bytes, 8);
+#if WORDS_BIGENDIAN
+	if (tds->emul_little_endian) {
+		l = TDS_GET_A4LE(bytes);
+		h = (TDS_INT) TDS_GET_A4LE(bytes+4);
+	} else {
+		h = (TDS_INT) TDS_GET_A4(bytes);
+		l = TDS_GET_A4(bytes+4);
+	}
+#else
+	l = TDS_GET_A4(bytes);
+	h = (TDS_INT) TDS_GET_A4(bytes+4);
+#endif
+	return (((TDS_INT8) h) << 32) | l;
+}
+
 #if ENABLE_EXTRA_CHECKS
 # define TEMP_INIT(s) char* temp = (char*)malloc(32); const size_t temp_size = 32
 # define TEMP_FREE free(temp);
 # define TEMP_SIZE temp_size
 #else
 # define TEMP_INIT(s) char temp[s]
 # define TEMP_FREE ;
 # define TEMP_SIZE sizeof(temp)
 #endif
 
Index: src/tds/token.c
===================================================================
RCS file: /cvsroot/freetds/freetds/src/tds/token.c,v
retrieving revision 1.337
diff -u -1 -0 -r1.337 token.c
--- src/tds/token.c	16 Oct 2007 15:12:22 -0000	1.337
+++ src/tds/token.c	18 Oct 2007 08:22:35 -0000
@@ -494,21 +494,21 @@
  * @retval TDS_NO_MORE_RESULTS if all results have been completely processed.
  * @retval anything returned by one of the many functions it calls.  :-(
  */
 int
 tds_process_tokens(TDSSOCKET *tds, TDS_INT *result_type, int *done_flags, unsigned flag)
 {
 	int marker;
 	TDSPARAMINFO *pinfo = NULL;
 	TDSCOLUMN   *curcol;
 	int rc;
-	int saved_rows_affected = tds->rows_affected;
+	TDS_INT8 saved_rows_affected = tds->rows_affected;
 	TDS_INT ret_status;
 	int cancel_seen = 0;
 	unsigned return_flag = 0;
 
 #define SET_RETURN(ret, f) \
 	*result_type = ret; \
 	return_flag = TDS_RETURN_##f | TDS_STOPAT_##f; \
 	if (flag & TDS_STOPAT_##f) {\
 		tds_unget_byte(tds); \
 		tdsdump_log(TDS_DBG_FUNC, "tds_process_tokens::SET_RETURN stopping on current token\n"); \
@@ -1436,21 +1436,21 @@
  */
 static int
 tds7_get_data_info(TDSSOCKET * tds, TDSCOLUMN * curcol)
 {
 	int colnamelen;
 
 	CHECK_TDS_EXTRA(tds);
 	CHECK_COLUMN_EXTRA(curcol);
 
 	/*  User defined data type of the column */
-	curcol->column_usertype = tds_get_smallint(tds);
+	curcol->column_usertype = IS_TDS90(tds) ? tds_get_int(tds) : tds_get_smallint(tds);
 
 	curcol->column_flags = tds_get_smallint(tds);	/*  Flags */
 
 	curcol->column_nullable = curcol->column_flags & 0x01;
 	curcol->column_writeable = (curcol->column_flags & 0x08) > 0;
 	curcol->column_identity = (curcol->column_flags & 0x10) > 0;
 
 	tds_set_column_type(tds, curcol, tds_get_byte(tds));	/* sets "cardinal" type */
 
 	curcol->column_timestamp = (curcol->column_type == SYBBINARY && curcol->column_usertype == TDS_UT_TIMESTAMP);
@@ -1489,20 +1489,24 @@
 		tds_get_n(tds, curcol->column_collation, 5);
 		curcol->char_conv =
 			tds_iconv_from_collate(tds, curcol->column_collation[4],
 					       curcol->column_collation[1] * 256 + curcol->column_collation[0]);
 	}
 
 	/* NOTE adjustements must be done after curcol->char_conv initialization */
 	adjust_character_column_size(tds, curcol);
 
 	if (is_blob_type(curcol->column_type)) {
+		/* discard this additional byte */
+		/* TODO discover its meaning */
+		if (IS_TDS90(tds))
+			tds_get_byte(tds);
 		curcol->table_namelen =
 			tds_get_string(tds, tds_get_smallint(tds), curcol->table_name, sizeof(curcol->table_name) - 1);
 	}
 
 	/*
 	 * under 7.0 lengths are number of characters not
 	 * number of bytes...tds_get_string handles this
 	 */
 	colnamelen = tds_get_string(tds, tds_get_byte(tds), curcol->column_name, sizeof(curcol->column_name) - 1);
 	curcol->column_name[colnamelen] = 0;
@@ -1600,20 +1604,23 @@
 	curcol->column_flags = tds_get_byte(tds);	/*  Flags */
 	if (!is_param) {
 		/* TODO check if all flags are the same for all TDS versions */
 		if (IS_TDS50(tds))
 			curcol->column_hidden = curcol->column_flags & 0x1;
 		curcol->column_key = (curcol->column_flags & 0x2) > 1;
 		curcol->column_writeable = (curcol->column_flags & 0x10) > 1;
 		curcol->column_nullable = (curcol->column_flags & 0x20) > 1;
 		curcol->column_identity = (curcol->column_flags & 0x40) > 1;
 	}
+	/* ?? */
+	if (IS_TDS90(tds))
+		tds_get_n(tds, NULL, 2);
 
 	curcol->column_usertype = tds_get_int(tds);
 	tds_set_column_type(tds, curcol, tds_get_byte(tds));
 
 	tdsdump_log(TDS_DBG_INFO1, "processing result. type = %d(%s), varint_size %d\n",
 		    curcol->column_type, tds_prtype(curcol->column_type), curcol->column_varint_size);
 	switch (curcol->column_varint_size) {
 	case 4:
 		curcol->column_size = tds_get_int(tds);
 		/* Only read table_name for blob columns (eg. not for SYBLONGBINARY) */
@@ -2195,20 +2202,21 @@
  * \param tds        state information for the socket and the TDS protocol
  * \param marker     TDS token number
  * \param flags_parm filled with bit flags (see TDS_DONE_ constants). 
  *        Is NULL nothing is returned
  */
 static int
 tds_process_end(TDSSOCKET * tds, int marker, int *flags_parm)
 {
 	int more_results, was_cancelled, error, done_count_valid;
 	int tmp, state;
+	TDS_INT8 rows_affected;
 
 	CHECK_TDS_EXTRA(tds);
 
 	tmp = tds_get_smallint(tds);
 
 	state = tds_get_smallint(tds);
 
 	more_results = (tmp & TDS_DONE_MORE_RESULTS) != 0;
 	was_cancelled = (tmp & TDS_DONE_CANCELLED) != 0;
 	error = (tmp & TDS_DONE_ERROR) != 0;
@@ -2238,27 +2246,26 @@
 	}
 
 	if (IS_TDSDEAD(tds))
 		return TDS_FAIL;
 
 	/*
 	 * rows affected is in the tds struct because a query may affect rows but
 	 * have no result set.
 	 */
 
-	if (done_count_valid) {
-		tds->rows_affected = tds_get_int(tds);
-		tdsdump_log(TDS_DBG_FUNC, "                rows_affected = %d\n", tds->rows_affected);
-	} else {
-		tmp = tds_get_int(tds);	/* throw it away */
+	rows_affected = IS_TDS90(tds) ? tds_get_int8(tds) : tds_get_int(tds);
+	tdsdump_log(TDS_DBG_FUNC, "                rows_affected = %" TDS_I64_FORMAT "\n", rows_affected);
+	if (done_count_valid)
+		tds->rows_affected = rows_affected;
+	else
 		tds->rows_affected = TDS_NO_COUNT;
-	}
 
 	if (IS_TDSDEAD(tds))
 		return TDS_FAIL;
 
 	return TDS_SUCCEED;
 }
 
 /**
  * tds_process_env_chg() 
  * when ever certain things change on the server, such as database, character
@@ -2306,31 +2313,53 @@
 			tds_get_n(tds, NULL, size - 5);
 			lcid = (tds->collation[0] + ((int) tds->collation[1] << 8) + ((int) tds->collation[2] << 16)) & 0xffffflu;
 			tds7_srv_charset_changed(tds, tds->collation[4], lcid);
 		}
 		tdsdump_dump_buf(TDS_DBG_NETWORK, "tds->collation now", tds->collation, 5);
 		/* discard old one */
 		tds_get_n(tds, NULL, tds_get_byte(tds));
 		return TDS_SUCCEED;
 	}
 
+	if (type == TDS_ENV_BEGINTRANS) {
+		size = tds_get_byte(tds);
+		tds_get_n(tds, tds->tds9_transaction, 8);
+		tds_get_n(tds, NULL, tds_get_byte(tds));
+		return TDS_SUCCEED;
+	}
+
+	if (type == TDS_ENV_COMMITTRANS || type == TDS_ENV_ROLLBACKTRANS) {
+		memset(tds->tds9_transaction, 0, 8);
+		tds_get_n(tds, NULL, tds_get_byte(tds));
+		tds_get_n(tds, NULL, tds_get_byte(tds));
+		return TDS_SUCCEED;
+	}
+
+	/* discard byte values, not still supported */
+	/* TODO support them */
+	if (type > TDS_ENV_PACKSIZE) {
+		/* discard new one */
+		tds_get_n(tds, NULL, tds_get_byte(tds));
+		/* discard old one */
+		tds_get_n(tds, NULL, tds_get_byte(tds));
+		return TDS_SUCCEED;
+	}
+
 	/* fetch the new value */
 	memrc += tds_alloc_get_string(tds, &newval, tds_get_byte(tds));
 
 	/* fetch the old value */
 	memrc += tds_alloc_get_string(tds, &oldval, tds_get_byte(tds));
 
 	if (memrc != 0) {
-		if (newval != NULL)
-			free(newval);
-		if (oldval != NULL)
-			free(oldval);
+		free(newval);
+		free(oldval);
 		return TDS_FAIL;
 	}
 
 	dest = NULL;
 	switch (type) {
 	case TDS_ENV_PACKSIZE:
 		new_block_size = atoi(newval);
 		if (new_block_size > tds->env.block_size) {
 			tdsdump_log(TDS_DBG_INFO1, "increasing block size from %s to %d\n", oldval, new_block_size);
 			/* 
@@ -2450,21 +2479,21 @@
 	/* the message */
 	rc += tds_alloc_get_string(tds, &msg.message, tds_get_smallint(tds));
 
 	/* server name */
 	rc += tds_alloc_get_string(tds, &msg.server, tds_get_byte(tds));
 
 	/* stored proc name if available */
 	rc += tds_alloc_get_string(tds, &msg.proc_name, tds_get_byte(tds));
 
 	/* line number in the sql statement where the problem occured */
-	msg.line_number = tds_get_smallint(tds);
+	msg.line_number = IS_TDS90(tds) ? tds_get_int(tds) : tds_get_smallint(tds);
 
 	/*
 	 * If the server doesen't provide an sqlstate, map one via server native errors
 	 * I'm assuming there is not a protocol I'm missing to fetch these from the server?
 	 * I know sybase has an sqlstate column in it's sysmessages table, mssql doesn't and
 	 * TDS_EED_TOKEN is not being called for me.
 	 */
 	if (msg.sql_state == NULL)
 		msg.sql_state = tds_alloc_lookup_sqlstate(tds, msg.msgno);
 
